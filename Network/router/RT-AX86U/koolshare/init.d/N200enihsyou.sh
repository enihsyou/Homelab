#!/bin/sh
# sourced by /jffs/.koolshare/bin/ks-net-start.sh,
# please link me, I will run when nat-start event occur.
# ln -s /jffs/.koolshare/enihsyou/N200enihsyou.sh /jffs/.koolshare/init.d/

source /koolshare/scripts/base.sh

my_log() {
  logger -st "N200enihsyou" "$*"
}

# make router responed to IPv6 ARP query
create_dnsmasq_lan_conf() {
  filename="/jffs/configs/dnsmasq.d/lan.conf"
  my_log "create $filename"
  ipv6_hostname="$(nvram get lan_hostname)" # RT-AX86U-CE58
  ipv6_hostname="$ipv6_hostname-IPv6"       # RT-AX86U-CE58-IPv6
  {
    echo "# file generated by $0"
    echo "# resolve self as IPv6 address when client doing DNS request"
    echo "interface-name=$ipv6_hostname,br0/6"
  } >"$filename"
}

# add iptables rule if not exist
add_iptables_rule() {
  # Initialize an empty string to build the arguments for the check command.
  check_args=''

  # Iterate through all the positional parameters (the arguments passed to the function).
  # This loop is POSIX-compliant and correctly handles arguments.
  for arg in "$@"; do
    case "$arg" in
    # If the argument is -A (append) or -I (insert, no argument after), add -C (check) to our string.
    -A | -I)
      check_args="$check_args -C"
      ;;
    # For any other argument, append it to the string.
    *)
      # Note the leading space to separate arguments.
      check_args="$check_args $arg"
      ;;
    esac
  done

  # Use 'eval' to execute the command string we built. The shell will perform word splitting
  # on the '$check_args' string and execute the result.
  # We redirect all output to /dev/null because we only care about the command's exit code.
  # The 'if ! ...' structure checks for a non-zero exit code.
  if ! eval "iptables $check_args" >/dev/null 2>&1; then
    # A non-zero exit code from 'iptables -C' means the rule does not exist.
    my_log "Rule not found, adding: iptables $*"
    iptables "$@"
  else
    # A zero exit code means the rule already exists.
    my_log "Rule already exists: iptables $*"
  fi
}

# append homebridge-miio iptables rules
create_iptables_homebridge_miio() {
  my_log "append homebridge-miio iptables rules"
  add_iptables_rule -t nat -I POSTROUTING -o br0 -p udp --dport 54321 -s 192.168.1.0/24 -m comment --comment "homebridge-miio" -j MASQUERADE
}

# bypass internal subnet from merlin clash
create_iptables_merlinclash_lan_subnets() {
  my_log "bypass internal subnet from merlin clash"
  # Note that dhcp option 121 in dnsmasq.d/pve.conf has already solved the problem that this iptables rule needs to address. Keeping this rule is harmless.
  add_iptables_rule -t mangle -I PREROUTING -d 192.168.0.0/16 -j RETURN
}

case $ACTION in
start_nat)
  create_dnsmasq_lan_conf
  create_iptables_homebridge_miio
  create_iptables_merlinclash_lan_subnets
  service restart_dnsmasq
  ;;
*)
  my_log "unknown action: '$ACTION', do nothing"
  ;;
esac
