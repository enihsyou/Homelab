#!/bin/sh
# sourced by /jffs/.koolshare/bin/ks-net-start.sh,
# please link me, I will run when nat-start event occur.
# ln -s /jffs/.koolshare/enihsyou/N200enihsyou.sh /jffs/.koolshare/init.d/

source /koolshare/scripts/base.sh

# make router responed to IPv6 ARP query
_LOG "create /jffs/configs/dnsmasq.d/lan.conf"
ipv6_hostname="$(nvram get lan_hostname)" # RT-AX86U-CE58
ipv6_hostname="$ipv6_hostname-IPv6"       # RT-AX86U-CE58-IPv6
{
  echo "# file generated by $0"
  echo "# resolve self as IPv6 address when client doing DNS request"
  echo "interface-name=$ipv6_hostname,br0/6"
} >/jffs/configs/dnsmasq.d/lan.conf

echo "restart dnsmasq service"
service restart_dnsmasq

link_postconf() {
  if [ ! -e "/jffs/scripts/$1" ]; then
    if [ -f "/jffs/.koolshare/enihsyou/$1" ]; then
      _LOG "link /jffs/scripts/$1"
      ln -svf "/jffs/.koolshare/enihsyou/$1" "/jffs/scripts/$1"
    else
      _LOG "$1 not found, please check"
    fi
  else
    _LOG "/jffs/scripts/$1 already exists, skip linking"
  fi
}

# link avahi-daemon.postconf
link_postconf avahi-daemon.postconf

add_iptables_rule() {
  # Initialize an empty string to build the arguments for the check command.
  check_args=''

  # Iterate through all the positional parameters (the arguments passed to the function).
  # This loop is POSIX-compliant and correctly handles arguments.
  for arg in "$@"; do
    case "$arg" in
    # If the argument is -A (append) or -I (insert, no argument after), add -C (check) to our string.
    -A | -I)
      check_args="$check_args -C"
      ;;
    # For any other argument, append it to the string.
    *)
      # Note the leading space to separate arguments.
      check_args="$check_args $arg"
      ;;
    esac
  done

  # Use 'eval' to execute the command string we built. The shell will perform word splitting
  # on the '$check_args' string and execute the result.
  # We redirect all output to /dev/null because we only care about the command's exit code.
  # The 'if ! ...' structure checks for a non-zero exit code.
  if ! eval "iptables $check_args" >/dev/null 2>&1; then
    # A non-zero exit code from 'iptables -C' means the rule does not exist.
    echo "Rule not found, adding: iptables $*"
    iptables "$@"
  else
    # A zero exit code means the rule already exists.
    echo "Rule already exists: iptables $*"
  fi
}

# append homebridge-miio iptables rules
_LOG "append homebridge-miio iptables rules"
add_iptables_rule -t nat -I POSTROUTING -o br0 -p udp --dport 54321 -s 192.168.1.0/24 -m comment --comment "homebridge-miio" -j MASQUERADE

# bypass internal subnet from merlin clash
_LOG "bypass internal subnet from merlin clash"
add_iptables_rule -t mangle -I PREROUTING -s 192.168.9.0/24 -d 192.168.2.0/24 -j RETURN
add_iptables_rule -t mangle -I PREROUTING -s 192.168.2.0/24 -d 192.168.9.0/24 -j RETURN

case $ACTION in
start_nat)
esac